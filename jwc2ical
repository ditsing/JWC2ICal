#!/usr/bin/perl -w

use strict;
use LWP;
use HTML::Tree;
use HTML::TreeBuilder;
use Encode;
use Data::ICal;
use Data::ICal qw(all);
use Data::ICal::Entry::TimeZone;
use Data::ICal::Entry::TimeZone::Standard;
#use Data::ICal::Entry::Event;
use utf8;

my $browser = LWP::UserAgent->new;
my $class_num = '0903101';
my $table_url = 'http://xscj.hit.edu.cn/Hitjwgl/XS/kfxqkb.asp';
my $date_url = 'http://jwc.hit.edu.cn/jwc/displaytwo.asp?ID=202';
my $time_url = 'http://jwc.hit.edu.cn/jwc/displaytwo.asp?ID=201';
my @num_name = qw{ 一 二 三 四 五 六 七 八 九 十 十一 十二};
my @num_syb = ( "\x{2474}", "\x{2475}", "\x{2476}", "\x{2477}", "\x{2478}", "\x{2479}",
	"\x{247A}", "\x{247B}", "\x{247C}", "\x{247D}", "\x{247E}", "\x{247F}", "\x{2480}",
	"\x{2481}", "\x{2482}", "\x{2483}", "\x{2484}", "\x{2485}", "\x{2486}", "\x{2487}");
my @length = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);

=pod
my $table = $browser->post( $table_url, [ "BH" => $class_num]);
&check( $table, $table_url);

my $date_table = $browser->get( $date_url);
&check( $date_table, $date_url);

my $time_table = $browser->get( $time_url);
&check( $time_table, $time_url);
=cut

# Now we get 3 valid tables. Although only few bytes are useful.
# Let's parse it now.
#
# The time table comes first;

my @class_times;

#my $time_tree = HTML::TreeBuilder->new_from_content( decode( 'gbk', $time_table->content));
open(my $tifh, "<:encoding(gbk)", "zxsj.htm") || die "no open tifh";
my $time_tree = HTML::TreeBuilder->new_from_file( $tifh);

# Look for a table data who has atleast 20 sons.
# This must be the class Schedule.
my $real_time = $time_tree->look_down( '_tag', 'td', sub{ $_[0]->content_list >= 20});

my $cnt = 0;
foreach ( $real_time->look_down( '_tag', 'p', sub{ $_[0]->as_text =~ m/第.*节：.*：/}))
{

	my $now = $_->as_text;
	# I hope you konw what i am doing.
	my $re_str = '[\s]*([\d]+)[\s]*';
	$now =~ s/第[\s]*(?<count>.*?)[\s]*节：$re_str：$re_str～$re_str：$re_str/$2:$3-$4:$5/;
	if ( $+{count} eq $num_name[$cnt])
	{
		push @class_times, [ [ $2, $3], [ $4, $5]];
	}
	else
	{
		print "Not really $cnt\n";
	}

	++$cnt;
}

# So the start and end time is stored in @class_times;
# Now for date table.

#my $date_tree = HTML::TreeBuilder->new_from_content( decode( 'gbk', $date_table->content));
open(my $dfh, "<:encoding(gbk)", "disp.htm") || die "no open";
my $date_tree = HTML::TreeBuilder->new_from_file( $dfh);

# Only the head is needed.
my $real_date = $date_tree->look_down( '_tag', 'thead');

# Get years out.
my $year_list = $real_date->look_down( '_tag', 'tr', sub { $_[0]->as_text =~ m/哈尔滨工业大学/});
my $year = $year_list->as_text;
$year =~ s/.*([\d]{4}).*/$1/;
print "year is $year.\n";

my @month;
my @month_length;

my %look_for;
foreach ( qw( 月 周 星期一 星期日))
{
	my $name = $_;
	$look_for{$name} = sub {
		bless $_[0], "HTML::Element";
		($_[0]->content_list)[0]->as_text eq $name
	};
}

# Get months out.
my $month_list = $real_date->look_down( '_tag', 'tr', $look_for{ 月});
#print $month_list->as_text, "\n";

foreach ( ($month_list->content_list)[1..($month_list->content_list-1)])
{
	push @month, &find( [ @num_name], $_->as_text);
	push @month_length, defined $_->attr( 'colspan') ? $_->attr( 'colspan') : 1;
}

# Get weeks out.
my $week_list = $real_date->look_down( '_tag', 'tr', $look_for{ 周});
my @weeks;

foreach ( ( $week_list->content_list)[1..($week_list->content_list-1)])
{
	my $num = &find( [ @num_syb], $_->as_text);
	push @weeks, $num ? $num + 100 : $_->as_text;
}
#print "@weeks", "\n";

foreach ( 1..@month_length)
{
	$month_length[$_] += $month_length[$_-1];
}

die "Not so useful date html ". ( scalar @weeks) . " and $month_length[-1]", "\n"
	if @weeks != $month_length[-1];

# Get dates of mondays and sundays out.
my @monday_dates;
my $monday_list = $real_date->look_down( '_tag', 'tr', $look_for{ 星期一});

foreach ( ( $monday_list->content_list)[1..($monday_list->content_list-1)])
{
	push @monday_dates, $_->as_text;
}

my @sunday_dates;
my $sunday_list = $real_date->look_down( '_tag', 'tr', $look_for{ 星期日});

foreach ( ( $sunday_list->content_list)[1..($sunday_list->content_list-1)])
{
	push @sunday_dates, $_->as_text;
}

# We only need the first monday here.
my @first_monday;
my $month = $month[0];

if ( $monday_dates[0] != $sunday_dates[0] - 6 && $sunday_dates[0] > 3)
{
	# Some wrong date are present, egg pain.
	--$year, $month = 12 if ( --$month == 0);
}
# Normal case
push @first_monday, $year;
push @first_monday, $month; 	 # Here is $month, not $month[0] !
push @first_monday, $monday_dates[0];


# This is a test output
print &find_date( [ @first_monday], 28), "\n";

#print "@first_monday\n". ( scalar @first_monday)."\n";

#my $table_tree = HTML::TreeBuilder->new_from_content( decode( 'gbk', $table->content));
open(my $tfh, "<:encoding(gbk)", "kfx.htm") || die "no open tfh";
my $table_tree = HTML::TreeBuilder->new_from_file( $tfh);

# Or I may need to find out tbody.
my $real_table = $table_tree->look_down( '_tag', 'table', sub { $_[0]->content_list >= 7 } );
#print $real_table->as_text, "\n";

my @classes;
my %courses;
# @classes[lesson][day][count] represents a class. 
# A class is made up of four lines: Course Name, Teacher, Classroom, During.
# We do have 6 big lessons everyday.
foreach ( 1..6)
{
	my $b = $_*2;
	my $a = $b - 1;
	my $lesson = $real_table->look_down( '_tag', 'tr', sub { $_[0]->as_text =~ m/($a)-($b)节/} );
	my @scope = ();
	# The first one is "a-b节", seven days a week, so 1..7.
	foreach ( 1..7)
	{
		my $data = ( $lesson->content_list)[$_];
		# Some data contains empty lines, so if there is a <tr>, there is a valid class.
		if ( $data->look_down( '_tag', 'tr'))
		{
#				print "$a, day $_: ", $data->as_text, "\n";
			my @str;
			my @tmp = ();

			# They put them into a table, too. Painfully.
			foreach ( ( ( $data->look_down( '_tag', 'table'))[0])->content_list)
			{
#					print "\tnow : ", $_->as_text, "\n";

				# Classes are sperated by <hr>s in each <tr>.
				if ( $_->look_down( '_tag', 'hr'))
				{
#					print "Get @tmp at $a-$b\n";
					&check_and_push( \@tmp, \@str);
				}
				else
				{
					# There will be two ( or more) empty lines after each
					# '周考试' entry, egg pain.
					if ( not $_->as_text eq "")
					{
						# When ARRAY @tmp has been pushed the course name,
						# the following one is Teacher and Location.
						# Such as "王忠杰 软件工程" ans "吴 锐 嵌入式"
						if ( @tmp == 1)
						{
							my @names = split /\s+/, $_->as_text;
							if ( @names != 2)
							{
								my $name;
								foreach ( @names[0..@names-2])
								{
									$name .= $_;
								}
								$names[0] = $name;
							}
							# The first and last ones are always useful.
							push @tmp, $names[0];
							push @tmp, $names[-1];
						}
						else
						{
							push @tmp, $_->as_text;
						}
					}
				}
			}

			# The last one is not followed by a <hr>
			&check_and_push( \@tmp, \@str);
			$scope[$_-1] = [ @str];
		}
	}
	$classes[$_-1] = [ @scope];
}

#print ( ($real_table->content_list)[6]->as_text);
# Look for a row contains '考试安排'
my $exams_table = $real_table->look_down( '_tag', 'tr', sub { $_[0]->as_text =~ m/考\s+试\s+安\s+排/} );
$exams_table = $exams_table->look_down( '_tag', 'table');
my @exams;
foreach my $exam ( $exams_table->look_down( '_tag', 'td'))
{
	if ( not $exam->as_text eq '')
	{
		my @exam_info = split /\s+/, $exam->as_text;
		# Format is: Week, day, time, location, subject. 
		print "Get @exam_info\n";
		warn "Not expected data @exam_info" if @exam_info != 5;
		my $time = $exam_info[2];
		# Say that the start time and end time is all two digits. Like 08:00-10:00.
		# As far as I know, HIT never starts an exam at 8:00 in the morning.
		warn "Time format is not recognized: $time" if not $time =~ m/(\d\d):(\d\d)-(\d\d):(\d\d)/;
		my @time;
		push @time, [ $1, $2], [ $3, $4];
		# Replace the string with a reference.
		$exam_info[2] = [ @time];
		push @exams, [ @exam_info];
	}
}

# All informations are available now.
my $vcal = Data::ICal->new();
# Copied from export data of Google Calender.
$vcal->add_properties(
	method => "PUBLISH",
	calscale => "GREGORIAN",
	"X-WR-CALNAME" => "哈工大课表", # Need more specification
	"X-WR-TIMEZONE" => "Asia/ShangHai"); # Or Harbin.

my $vtz = Data::ICal::Entry::TimeZone->new();
$vtz->add_properties(
	tzid => "Asia/ShangHai", 
	"X-LIC-LOCATION" => "Asia/ShangHai"); # I think this is nothing, too.

my $vtz_std = Data::ICal::Entry::TimeZone::Standard->new();

$vtz_std->add_properties(
	tzoffsetfrom => "+0800",
	tzoffsetto => "+0800",
	tzname => "CST",
	dtstart => "19700101T000000");

$vtz->add_entry( $vtz_std);
$vcal->add_entry( $vtz);

print $vcal->as_string, "\n";

# Events come here
foreach my $i ( 0..5)
{
	foreach my $j ( 0..6)
	{
		foreach my $k ( @{$classes[$i][$j]})
		{
			my @class_info = @$k;
			# Find out when the first class starts.
			my @date = &find_date( [ @first_monday], $j + ${$class_info[3]}[0] * 7 - 7);

			# Until now ( 2012.1), JWC does not support a class ends at the middle of a week.
			# So I do not condsider it.
			my $during = ${$class_info[3]}[1] - ${$class_info[3]}[0];

			my $first_class_time = Date::ICal->new(
				year   		=> $date[0],
				month		=> $date[1],
				day    		=> $date[2],
				hour   		=> $${$class_times[$i*2]}[0][0],
				min    		=> $${$class_times[$i*2]}[0][1],
				sec    		=> 0,
				offset 		=> "+0800",
			);

			my $first_class_end_time = Date::ICal->new(
				year   		=> $date[0],
				month		=> $date[1],
				day    		=> $date[2],
				hour   		=> $${$class_times[$i*2]}[1][0],
				min    		=> $${$class_times[$i*2]}[1][1],
				sec    		=> 0,
				offset 		=> "+0800",
			);

			my $vevent = Data::ICal::Entry::Event->new();
			$vevent->add_properties(
				dtstart 	=> $first_class_time->ical,
				dtend	  	=> $first_class_time->ical,
				rrule 		=> "FREQ=weekly;UNTILE=$first_class_time->ical;BYDAY=NO",
				exdate 		=> $first_class_time->ical,
				dtsamp 		=> $first_class_time->ical,
				description  	=> $class_info[1], 					# Teacher
				location 	=> $class_info[0], 					# Class room
				sequence 	=> 1,
				status 		=> "CONFIRMED",
				summary 	=> $class_info[2], 					# Course name
				transp 		=> "OPAQUE",
			);

			my $valarm = Data::ICal::Alarm->new();
			$valarm->add_properties(
				action 		=> "DISPLAY",
				description 	=> "This is an event reminder",
				trigger 	=> Date::ICal()->new(),
			);

			$vevent->add_entry( $valarm);
			$vcal->add_entry( $vevent);
		}
	}
}

exit;

sub check_and_push
{
	# Examinations are ignored and they will be processed later.
	if ( not ${$_[0]}[0] =~ m/周考试/)
	{
		warn "Not expected data @$_[0]" if @$_[0] != 4;
		my $weeks = ${$_[0]}[3];
		warn "Not recognized weeks at $weeks" if not $weeks =~ m/(\d*)-(\d*)周/;
		${$_[0]}[3] = [ $1, $2];

		push @$_[1], [ @$_[0]];
		++$courses{$$_[0][0]};
	}
}

sub find_date
{
	my $first_day = $_[0];
	my $year = ${$first_day}[0];
	my $month = ${$first_day}[1];
	my $date = ${$first_day}[2];
	my $day = $_[1];
	$date += $day;
#	print "y: $year m: $month d: $date w: $week day: $day\n";

	my @ret;
	my $found = undef;
	while ( !$found)
	{
		my $offset = $length[$month-1];
		++$offset if ( $month == 2 && $year % 4 == 0 && ( $year % 100 != 0 || $year % 400 == 0));
		if ( $date >= $offset)
		{
			$date -= $offset;
			++$month;
			$month = 1, ++$year if $month == 13;
		}
		else
		{
			$found = 1;
		}
	}

	push @ret, $year;
	push @ret, $month;
	push @ret, $date;
	return @ret;
}

sub find
{
	my $num = $_[0];
	foreach ( 1..@$num)
	{
		return $_ if ( $_[1] eq ${$num}[$_-1]);
	}
	return undef;
}

sub check
{
	my $response = $_[0];
	my $url = $_[1];
	die "$url error: ", $response->status_line unless $response->is_success;
	die "Weird content type at $url -- ", $response->content_type
		unless $response->content_type eq 'text/html';
#	print $response->content;

	return $response;
}

